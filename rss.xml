<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>khalily&#39;s Blog</title>
    <link>http://sample.com</link>
    <pubDate>2013-06-04 04:27:17 +0800</pubDate>
    <item>
      <title>知乎笔试</title>
      <link>http://sample.com/python/%E7%9F%A5%E4%B9%8E%E7%AC%94%E8%AF%95/</link>
      <pubDate>2013-06-04 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;知乎笔试题&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;p&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;1.过滤html标签&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;假设在一个文本编辑器中允许使用富文本，但只允许使用以下html标签和属性，&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;&amp;quot; title=&amp;quot;&amp;quot;&amp;gt; &amp;lt;abbr title=&amp;quot;&amp;quot;&amp;gt; &amp;lt;acronym title=&amp;quot;&amp;quot;&amp;gt; &amp;lt;b&amp;gt;&#xA;&amp;lt;blockquote cite=&amp;quot;&amp;quot;&amp;gt; &amp;lt;cite&amp;gt; &amp;lt;code&amp;gt; &amp;lt;del datetime=&amp;quot;&amp;quot;&amp;gt; &amp;lt;em&amp;gt; &amp;lt;i&amp;gt; &amp;lt;q&#xA;cite=&amp;quot;&amp;quot;&amp;gt; &amp;lt;strike&amp;gt; &amp;lt;strong&amp;gt;  &amp;lt;pre&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编写一个过滤器，对任意输入的文本进行过滤，输出符合要求的富文本&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/python env&#xA;#coding: utf8&#xA;&#xA;from BeautifulSoup import BeautifulSoup&#xA;&#xA;html = &#39;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Page title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;\&#xA;&amp;lt;p id=&amp;quot;firstpara&amp;quot; align=&amp;quot;center&amp;quot;&amp;gt;This is paragraph &amp;lt;b&amp;gt;one&amp;lt;/b&amp;gt;.\&#xA;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;&amp;quot;only test&amp;quot;;&amp;lt;/script&amp;gt;\&#xA;&amp;lt;a href=&amp;quot;&amp;quot; title=&amp;quot;&amp;quot; onclick=&amp;quot;&amp;quot;&amp;gt;test&amp;lt;/a&amp;gt;\&#xA;&amp;lt;p id=&amp;quot;secondpara&amp;quot; align=&amp;quot;blah&amp;quot;&amp;gt;This is paragraph &amp;lt;b&amp;gt;two&amp;lt;/b&amp;gt;.&amp;lt;/html&amp;gt;&#39;&#xA;&#xA;# &amp;lt;a href=&amp;quot;&amp;quot; title=&amp;quot;&amp;quot;&amp;gt; &amp;lt;abbr title=&amp;quot;&amp;quot;&amp;gt; &amp;lt;acronym title=&amp;quot;&amp;quot;&amp;gt; &amp;lt;b&amp;gt;&#xA;# &amp;lt;blockquote cite=&amp;quot;&amp;quot;&amp;gt; &amp;lt;cite&amp;gt; &amp;lt;code&amp;gt; &amp;lt;del datetime=&amp;quot;&amp;quot;&amp;gt; &amp;lt;em&amp;gt; &amp;lt;i&amp;gt; &amp;lt;q&#xA;# cite=&amp;quot;&amp;quot;&amp;gt; &amp;lt;strike&amp;gt; &amp;lt;strong&amp;gt;  &amp;lt;pre&amp;gt;&#xA;&#xA;WHITE_LIST = {&#39;a&#39;: {&#39;href&#39;: &#39;*&#39;, &#39;title&#39;: &#39;*&#39;}, &#39;abbr&#39;: {&#39;title&#39;: &#39;*&#39;},&#xA;              &#39;acronym&#39;: {&#39;title&#39;: &#39;*&#39;}, &#39;b&#39;: {}, &#39;blockquote&#39;: {&#39;cite&#39;: &#39;*&#39;},&#xA;              &#39;cite&#39;: {}, &#39;code&#39;: {}, &#39;i&#39;: {}, &#39;del&#39;: {&#39;datetime&#39;: &#39;*&#39;},&#xA;              &#39;em&#39;: {}, &#39;q&#39;: {&#39;cite&#39;: &#39;*&#39;}, &#39;strike&#39;: {}, &#39;strong&#39;: {},&#xA;              &#39;pre&#39;: {}}&#xA;&#xA;&#xA;def parseHtml(html):&#xA;    soup = BeautifulSoup(html)&#xA;    for tag in soup.findAll(True):&#xA;        if tag.name not in WHITE_LIST:&#xA;            tag.hidden = True&#xA;        else:&#xA;            attr_rules = WHITE_LIST[tag.name]&#xA;            for attr_name, attr_value in tag.attrs:&#xA;                if attr_name not in attr_rules:&#xA;                    del tag[attr_name]&#xA;&#xA;    return soup.renderContents()&#xA;&#xA;&#xA;if __name__ == &#39;__main__&#39;:&#xA;    print parseHtml(html)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;p&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;2.假设给你一个月的日志，格式如下：&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[I 130403 17:26:40] 1 200 GET /question/123 (8.8.9.9) 200.39ms&#xA;[I 130403 17:26:90] 1 200 GET /topic/456 (8.8.9.9) 300.85ms&#xA;[I 130403 17:26:90] 1 200 POST /answer/789 (8.8.9.9) 300.85ms&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;方括号中依次是：级别，日期，时间，后面依次是用户id，返回码，访问方式，访问路径，用户ip，响应时间&lt;/p&gt;&#xA;&#xA;&lt;p&gt;日志文件名格式为：年-月-日-小时.log，如：2013-01-01-18.log，共30*24个文件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;写个程序，算出一个用户列表同时符合以下两个要求：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;这些用户每天都会访问（GET）/topic/***这个路径至少两次（*代表数字）&lt;/li&gt;&#xA;&lt;li&gt;这些用户每天访问（GET）的/topic/***路径中，至少会包含两个不同的路径（后面的数字不一样）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;再算出一个路径列表满足:&#xA;每天都被以上用户中至少两个用户访问&lt;/p&gt;&#xA;&#xA;&lt;p&gt;实现思路：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;实现思路是先把一个月的30*24个文件名分天存储在一个filepaths_one_month列表 [[filepaths_one_day], ...]&#xA;然后算出每一天符合要求的用户访问的路径列表 user_dict_day {user_id: [path, ...]} 和 符合要求的被访问路径的用户列表&#xA; path_dict_day {path: [user_id, ...]}, 然后把每天的user_dict_day的keys 求交集，求出每天都访问的用户，再用其为key, 找到这些用户访问的路径列表交集不为空的user_id, 即为要求1的答案user_list，接下来则对path_dict_day进行相同的操作，得出每天都被至少两个用户访问的路径列表，最后再用访问这些路径的用户列表与要求1求出的用户列表求交集，得出使交集不为空的path_list.&#xA;&#xA;需要说明一点，日志文件的年、月、日都在test()函数设置，然后在当前文件夹寻找日志文件，日志的小时范围为00点-23点(而不是01点-24点)。为了一些可读性，包含了一些较冗余的代码，不过代码不多，相信影响不大。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python&#xA;#coding: utf8&#xA;&#xA;import re&#xA;&#xA;log_keys = [&#xA;    &#39;user_id&#39;,&#xA;    &#39;return_code&#39;,&#xA;    &#39;access_way&#39;,&#xA;    &#39;access_path&#39;,&#xA;    &#39;ip_address&#39;,&#xA;    &#39;time&#39;&#xA;]&#xA;&#xA;&#xA;class Find(object):&#xA;    def __init__(self, days, month, year):&#xA;        self.filepaths_one_month = self.file_paths(days, month, year)&#xA;        # for filepaths_day in self.filepaths_one_month:&#xA;        #     for filepath in filepaths_day:&#xA;        #         print filepath&#xA;        self.user_dict_month = {}       # {user_id: {path, ...}}&#xA;        self.path_dict_month = {}       # {path: {user_id, ...}}&#xA;&#xA;    def find_one_month(self):&#xA;        user_dict_pre_day, path_dict_pre_day = self.find_one_day(self.filepaths_one_month[0])&#xA;        for filepaths_one_day in self.filepaths_one_month[1:]:&#xA;            user_dict_day, path_dict_day = self.find_one_day(filepaths_one_day)&#xA;            user_set = set(user_dict_day.keys()) &amp;amp; set(user_dict_pre_day.keys())&#xA;            for user_id in user_set:&#xA;                path_set = set(user_dict_day[user_id]) &amp;amp; set(user_dict_pre_day[user_id])&#xA;                if len(path_set) &amp;gt; 0:&#xA;                    self.user_dict_month[user_id] = path_set&#xA;            user_dict_pre_day = self.user_dict_month&#xA;&#xA;            path_set = set(path_dict_day.keys()) &amp;amp; set(path_dict_pre_day.keys())&#xA;            for path in path_set:&#xA;                user_set = set(path_dict_day[path]) &amp;amp; set(path_dict_pre_day[path])&#xA;                self.path_dict_month[path] = user_set&#xA;            path_dict_pre_day = self.path_dict_month&#xA;&#xA;        user_list = self.user_dict_month.keys()&#xA;        path_list = []&#xA;&#xA;        for path in self.path_dict_month.keys():&#xA;            if len(self.path_dict_month[path] &amp;amp; set(user_list)) &amp;gt; 0:&#xA;                path_list.append(path)&#xA;&#xA;        return user_list, path_list&#xA;&#xA;    def file_paths(self, days, month, year):&#xA;        filepaths = []&#xA;        for day in xrange(1, days+1):&#xA;            filepaths_day = []&#xA;            for hour in xrange(0, 24):&#xA;                temppath = &amp;quot;%2d-%2d-%2d-%2d.log&amp;quot; % (year, month, day, hour)&#xA;                filepaths_day.append(temppath.replace(&#39; &#39;, &#39;0&#39;))&#xA;            filepaths.append(filepaths_day)&#xA;        return filepaths&#xA;&#xA;    def find_one_day(self, filepaths):&#xA;        user_dict = {}          # {user_id: {path: times}}&#xA;        user_dict_day = {}      # {user_id: [path, ...]}&#xA;        path_dict = {}          # {path: {user_id: times}}&#xA;        path_dict_day = {}      # {path: [user_id, ...]}&#xA;&#xA;        for filepath in filepaths:&#xA;            for line in file(filepath).readlines():&#xA;                if not self.is_get_and_topic(line):&#xA;                    continue&#xA;                log_dict = self.parser_line(line)&#xA;&#xA;                user_id = log_dict[&#39;user_id&#39;]&#xA;                path = log_dict[&#39;access_path&#39;]&#xA;                if user_id not in user_dict:&#xA;                    user_dict[user_id] = {}&#xA;                if path not in user_dict[user_id]:&#xA;                    user_dict[user_id][path] = 1&#xA;                else:&#xA;                    user_dict[user_id][path] = user_dict[user_id][path] + 1&#xA;&#xA;                if path not in path_dict:&#xA;                    path_dict[path] = {}&#xA;                if user_id not in path_dict[path]:&#xA;                    path_dict[path][user_id] = 1&#xA;                else:&#xA;                    path_dict[path][user_id] = path_dict[path][user_id] + 1&#xA;&#xA;        for user_id in user_dict.keys():&#xA;            for path in user_dict[user_id].keys():&#xA;                if user_dict[user_id][path] &amp;gt;= 2 and len(user_dict[user_id].keys()) &amp;gt;= 2:&#xA;                    if user_id not in user_dict_day:&#xA;                        user_dict_day[user_id] = []&#xA;                    user_dict_day[user_id].append(path)&#xA;        # print &#39;user_dict_day:&#39;, user_dict_day&#xA;&#xA;        for path in path_dict.keys():&#xA;            for user_id in path_dict[path].keys():&#xA;                if path_dict[path][user_id] &amp;gt;= 2:&#xA;                    if path not in path_dict_day:&#xA;                        path_dict_day[path] = []&#xA;                    path_dict_day[path].append(user_id)&#xA;        # print &#39;path_dict_day:&#39;, path_dict_day&#xA;&#xA;        return user_dict_day, path_dict_day&#xA;&#xA;    def parser_line(self, str):&#xA;        log_list = str[(str.find(&#39;]&#39;)+2):].split(&#39; &#39;)&#xA;        log_dict = {}&#xA;        for index in range(0, len(log_list)):&#xA;            log_dict[log_keys[index]] = log_list[index]&#xA;        # for key, value in log_dict.items():&#xA;        #     print key, value&#xA;        return log_dict&#xA;&#xA;    def is_get_and_topic(self, str):&#xA;        if re.search(&#39;GET /topic/[0-9]+&#39;, str):&#xA;            return True&#xA;        return False&#xA;&#xA;&#xA;def test():&#xA;    days = 30        # 一个月的天数&#xA;    year = 2013&#xA;    month = 1&#xA;    test = Find(days, month, year)&#xA;    user_list, path_list = test.find_one_month()&#xA;&#xA;    print &#39;user_list:&#39;, user_list&#xA;    print &#39;path_list:&#39;, path_list&#xA;&#xA;if __name__ == &#39;__main__&#39;:&#xA;    test()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>caculate</title>
      <link>http://sample.com/go/caculate/</link>
      <pubDate>2013-06-03 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;用 golang 实现的计算器&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;功能支持&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;简单四则运算&lt;/li&gt;&#xA;&lt;li&gt;优先级支持&lt;/li&gt;&#xA;&lt;li&gt;小括号支持&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;简单演示&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ ./caculator &#xA;Please input express:&#xA;1+2*1-12+2-(1+2*3)&#xA;[1 + 2 * 1 - 12 + 2 - ( 1 + 2 * 3 )]      //中缀表达式&#xA;[1 2 1 * + 12 - 2 + 1 2 3 * + -]            //后缀表达式&#xA;-14                                     //结果&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;实现流程&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/caculate.png&#34; alt=&#34;caculate.png&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;后缀到前缀的转换&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func pre2stuf(exps []string) (exps2 []string) {&#xA;    list1 := list.New()&#xA;    list2 := list.New()&#xA;&#xA;    for _, exp := range exps {&#xA;        if isOperate(exp) {&#xA;            if op, ok := isPop(list1, exp); ok {&#xA;                for _, s := range op {&#xA;                    list2.PushBack(s)&#xA;                }&#xA;            }&#xA;            if exp == &amp;quot;)&amp;quot; {&#xA;                continue&#xA;            }&#xA;            list1.PushBack(exp)&#xA;        } else {&#xA;            list2.PushBack(exp)&#xA;        }&#xA;    }&#xA;&#xA;    for cur := list1.Back(); cur != nil; cur = cur.Prev() {&#xA;        list2.PushBack(cur.Value)&#xA;    }&#xA;&#xA;    for cur := list2.Front(); cur != nil; cur = cur.Next() {&#xA;        if curValue, ok := cur.Value.(string); ok {&#xA;            exps2 = append(exps2, curValue)&#xA;        }&#xA;    }&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;代码在&lt;a href=&#34;https://github.com/khalily/caculator&#34;&gt;这里&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone git@github.com:khalily/caculator.git&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;欢迎交流！^_^&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>gscan</title>
      <link>http://sample.com/go/gscan/</link>
      <pubDate>2013-05-31 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;用Go语言实现的一个端口扫描器&amp;ndash;gscan&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;程序功能参数&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Usage of ./gscan:&#xA;  -h=&amp;quot;help&amp;quot;: help doc&#xA;  -ip=&amp;quot;127.0.0.1&amp;quot;: IP range of scan. Example:&#xA;        192.168.1.1&#xA;        192.168.1.1, 192.168.1.5&#xA;        192.168.1.1-192.168.1.100&#xA;  -p=&amp;quot;1-1024&amp;quot;: Port range of scan. Example:&#xA;        135&#xA;        135, 445, 3389&#xA;        1-1024&#xA;  -w=&amp;quot;connect&amp;quot;: Way of scan. Expample&#xA;        connect&#xA;        syn&#xA;        fin &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;实现思想&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一个端口一个&lt;code&gt;goroutine&lt;/code&gt;，用一个&lt;code&gt;chanel&lt;/code&gt;接收所有&lt;code&gt;goroutine&lt;/code&gt;返回的扫描结果&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;代码在&lt;a href=&#34;https://github.com/khalily/gscan&#34;&gt;这里&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone git@github.com:khalily/gscan.git&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;欢迎交流！^_^&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>